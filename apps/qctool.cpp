
//          Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

/*
 * This program, qctool, selects rows from a GEN file according to certain criteria.
 * - rows where some genotype data is missing, or none is.
 * - rows where genotype data is, or is not in hardy-weinberg equilibrium.
 * - rows with SNP IDs in a given list.
 *
 * Program arguments:
 *
 */

#include <string>
#include <map>
#include <set>
#include <fstream>
#include <memory>
#include <numeric>
#include <boost/bind.hpp>
#include <boost/shared_ptr.hpp>
#include <boost/foreach.hpp>

#include "Timer.hpp"
#include "GenRow.hpp"
#include "SampleRow.hpp"
#include "appcontext/CmdLineOptionProcessor.hpp"
#include "appcontext/OptionProcessor.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "RowCondition.hpp"
#include "SNPInListCondition.hpp"
#include "SNPIDMatchesCondition.hpp"
#include "SampleInListCondition.hpp"
#include "FileUtil.hpp"
#include "GenRowStatistics.hpp"
#include "SampleRowStatistics.hpp"
#include "ObjectSource.hpp"
#include "SimpleFileObjectSource.hpp"
#include "SimpleFileObjectSink.hpp"

#include "genfile/SNPDataSource.hpp"
#include "genfile/SNPDataSourceChain.hpp"
#include "genfile/SNPDataSourceRack.hpp"
#include "genfile/MergingSNPDataSource.hpp"
#include "genfile/SNPDataSinkChain.hpp"
#include "genfile/GenFileSNPDataSink.hpp"
#include "genfile/SortingBGenFileSNPDataSink.hpp"
#include "genfile/TrivialSNPDataSink.hpp"
#include "genfile/CategoricalCohortIndividualSource.hpp"
#include "genfile/CountingCohortIndividualSource.hpp"
#include "genfile/SampleFilteringCohortIndividualSource.hpp"
#include "genfile/CohortIndividualSourceChain.hpp"
#include "genfile/SampleFilteringSNPDataSource.hpp"
#include "genfile/SNPTranslatingSNPDataSource.hpp"
#include "genfile/StrandAligningSNPDataSource.hpp"
#include "genfile/AlleleFlippingSNPDataSource.hpp"
#include "genfile/AsynchronousSNPDataSource.hpp"
#include "genfile/VCFFormatSNPDataSource.hpp"
#include "genfile/Pedigree.hpp"
#include "genfile/PedFileSNPDataSink.hpp"
#include "genfile/BedFileSNPDataSink.hpp"
#include "genfile/CommonSNPFilter.hpp"
#include "genfile/SNPFilteringSNPDataSource.hpp"
#include "genfile/SNPIdentifyingDataFilteringSNPDataSource.hpp"
#include "genfile/get_list_of_snps_in_source.hpp"
#include "genfile/utility.hpp"
#include "genfile/QuantileNormalisingCrossCohortCovariateValueMapping.hpp"
#include "genfile/ValueMappingCohortIndividualSource.hpp"
#include "genfile/vcf/StrictMetadataParser.hpp"
#include "genfile/WithSNPDosagesCohortIndividualSource.hpp"
#include "genfile/get_set_eigen.hpp"

#include "statfile/BuiltInTypeStatSource.hpp"
#include "statfile/from_string.hpp"
#include "statfile/read_values.hpp"
#include "statfile/SNPDataSourceAdapter.hpp"

#include "appcontext/appcontext.hpp"

#include "worker/QueuedMultiThreadedWorker.hpp"
#include "worker/SynchronousWorker.hpp"

#include "SampleOutputFile.hpp"
#include "GenotypeAssayStatisticFactory.hpp"
#include "string_utils/string_utils.hpp"
#include "string_utils/parse_utils.hpp"
#include "progress_bar.hpp"
#include "FileBackupCreator.hpp"
#include "InputToOutputFilenameMapper.hpp"
#include "OstreamTee.hpp"
#include "null_ostream.hpp"
#include "SNPPositionSink.hpp"
#include "SNPIDSink.hpp"
#include "statfile/BuiltInTypeStatSink.hpp"
#include "SampleIDSink.hpp"
#include "QCToolContext.hpp"
#include "QCTool.hpp"
#include "Relatotron.hpp"
#include "VCDBWriter.hpp"
#include "DataReadTest.hpp"
#include "ClusterFitter.hpp"
#include "components/RelatednessComponent/RelatednessComponent.hpp"
#include "components/CallComparerComponent/CallComparerComponent.hpp"
#include "components/HaplotypeFrequencyComponent/HaplotypeFrequencyComponent.hpp"
#include "components/SNPSummaryComponent/SNPSummaryComponent.hpp"
#include "components/SNPOutputComponent/SNPOutputComponent.hpp"
#include "components/SampleSummaryComponent/SampleSummaryComponent.hpp"
#include "ClusterPlotter.hpp"

#include "qctool_version_autogenerated.hpp"

namespace globals {
	std::string const program_name = "qctool" ;
	std::string const program_version = qctool_revision ;
}

struct NumberOfSamplesMismatchException: public QCToolException
{
	char const* what() const throw() {return "NumberOfSamplesMismatchException" ; }
} ;

// Thrown to indicate that the numbers of input and output files specified on the command line differ.
struct QCToolFileCountMismatchError: public QCToolException
{
	char const* what() const throw() {return "QCToolFileCountMismatchError" ; }
} ;

struct QCToolOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;

		// File options
		options.declare_group( "Input file options" ) ;
	    options[ "-g" ]
	        .set_description( 	"Path of gen file(s) to input.  "
								"The given filename may contain the wildcard character '#', which expands to match a"
								"one- or two-character chromosome identifier.  (For example, \"qctool -g myfile_#.gen\" will match "
								"\"myfile_1.gen\", \"myfile_2.gen\", etc., or \"myfile_01.gen\", \"myfile_02.gen\", etc.)  Only human"
								" autosomes are matched this way.\n"
								"This option may also be repeated, in which case each invocation is treated as a seperate cohort and cohorts"
								" are joined together to create one big dataset." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 100 ) ;

	    options[ "-filetype" ]
			.set_description(
				"Specify the filetype of the genotype files specified by -g. "
				"By default, qctool will guess the file type.  Use this option to override that guess. "
				"Possible types are: \"" + genfile::string_utils::join( genfile::SNPDataSource::get_file_types(), "\",\"" ) + "\"." )
			.set_takes_single_value() ;

		options[ "-merge-in" ]
			.set_description( "Specify an additional set of genotypes that should be merged in (in position order) to the dataset. "
				"This must have the same number of samples as the data set for -g. "
				"Note that filtering, strand alignment, allele matching, or other transformations are not applied to the data "
				"specified by -merge-in.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;

		options[ "-merge-strategy" ]
			.set_description( "Specify a strategy to use when encountering SNPs with the same position in a merge. "
				"Options are \"" + genfile::string_utils::join( genfile::MergingSNPDataSource::get_merge_strategies(), "\",\"" ) + "\"." )
			.set_takes_single_value()
			.set_default_value( "keep-all" ) ;
		options[ "-merge-prefix" ]
			.set_description( "Specify a string to add as a prefix to ID fields of merged-in variants" )
			.set_takes_single_value()
			.set_default_value( "" ) ;
		
	    options[ "-s" ]
	        .set_description( "Path of sample file to input.  If specified, this option must occur as often as the -g option"
							" to specify one sample file per cohort." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;

/*	    options[ "-i" ]
	        .set_description( 	"Path of intensity file(s) to input.  "
								"If specified, this option must occur the same number of times as the -g option, to specify"
								" one intensity file per cohort."
								"As with -g the '#' wildcard character may be used to match chromosomes." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 100 ) ;
*/
		options.declare_group( "Sample exclusion options" ) ;
		options[ "-incl-samples"]
			.set_description( "Filter out samples whose sample ID does not lie in the given file(s).")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-samples"]
			.set_description( "Filter out samples whose sample ID lies in the given file.")
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;

		// SNP exclusion options
		options.declare_group( "SNP exclusion options" ) ;
		options[ "-excl-snps" ]
			.set_description( "Exclude all SNPs in the given file(s) from the analysis."
				" The format of this file is the same as that output by the -write-snp-excl-list option. "
				" It must have six columns interpreted as SNPID, rsid, chromosome, position, first and second alleles." )
			.set_takes_values( 1 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-snps" ]
			.set_description( "Exclude all SNPs not in the given file(s) from the analysis."
				" The format of this file is the same as that output by the -write-snp-excl-list option. "
				" It must have six columns interpreted as SNPID, rsid, chromosome, position, first and second alleles." )
			.set_takes_values( 1 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-snpids" ]
			.set_description( "Exclude all SNPs whose SNPID is in the given file(s) from the analysis.")
			.set_takes_values_until_next_option()
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-rsids" ]
			.set_description( "Exclude all SNPs whose RSID is in the given file(s) from the analysis.")
			.set_takes_values_until_next_option()
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-snpids" ]
			.set_description( "Exclude all SNPs whose SNPID is not in the given file(s) from the analysis.")
			.set_takes_values_until_next_option()
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-rsids" ]
			.set_description( "Exclude all SNPs whose RSID is not in the given file(s) from the analysis.")
			.set_takes_values_until_next_option()
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-positions" ]
			.set_description( "Exclude all SNPs whose position is in the given file(s) from the analysis. "
				"Positions should be in the form [chromosome]:[position] and separated by whitespace." )
			.set_takes_values_until_next_option() 
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-positions" ]
			.set_description( "Exclude all SNPs whose position is not in the given file(s) from the analysis. "
				"Positions should be in the form [chromosome]:[position] and separated by whitespace." )
			.set_takes_values_until_next_option() 
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-snps-matching" ]
			.set_description( "Filter out snps whose rsid or SNPID matches the given value. "
				"The value should be a string which can contain a % wildcard character (which matches any substring). "
				"Optionally, prefix the argument with snpid~ or rsid~ to only match against the SNPID or rsid fields." )
			.set_takes_single_value() ;
		options[ "-incl-snps-matching" ]
			.set_description( "Filter out snps whose rsid or SNPID does not match the given value. "
				"The value should be a string which can contain a % wildcard character (which matches any substring). "
				"Optionally, prefix the argument with snpid~ or rsid~ to only match against the SNPID or rsid fields." )
			.set_takes_single_value() ;
		options[ "-incl-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to operate on. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_single_value() ;
		options[ "-excl-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to exclude from operation. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_single_value() ;

		options.declare_group( "Options for adjusting SNPs" ) ;
	    options[ "-strand" ]
	        .set_description( 	"Path of strand file(s) to input.  "
								"If specified, this option must occur the same number of times as the -g option, to specify"
								" one intensity file per cohort." )
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-translate-snp-positions" ]
			.set_description( "Specify a \"dictionary\" of chromosome / position to chromosome / position mappings."
				" (This should come as a 12-column file with the first six columns the original SNPID rsid chromosome position allele1 allele2"
				" and the second six columns the same data with possibly different chromosome and position.)"
				" Positions of SNPs will be mapped through this dictionary before processing." )
			.set_takes_single_value() ;
		options[ "-match-alleles-to-cohort1" ]
			.set_description( "Specify that alleles (and corresponding genotypes) in all cohorts should be switched, if necessary,"
				" so as to match the alleles of the first cohort." ) ;
		options[ "-snp-match-fields" ]
			.set_description( "By default, matching SNPs between cohorts uses all the available fields"
				" (position, rsid, SNPID, and alleles.)"
				" Use this option to specify a comma-separated subset of those fields to use instead."
				" The first entry must be \"position\"."
				" This option can be used, for example, when cohorts are typed on different platforms so have different SNPID fields." )
			.set_takes_single_value()
			.set_default_value( "position,rsid,SNPID,alleles" ) ;
		options[ "-assume-chromosome" ]
			.set_description( "Treat each SNP whose chromosome cannot be determined"
				" as though it lies on the specified chromosome." )
			.set_takes_single_value() ;

		options.declare_group( "Output file options" ) ;
	    options[ "-og" ]
	        .set_description(
				"Specify that qctool should write an output genotype file with the specified filename. " 
				"The type of this file will be determined from the filename extension. "
				"If the first occurence of -g uses a '#' wildcard character, the '#' character can "
				"also be used here to specify numbered output files corresponding to the input files."
				"If \"-\" is specifed here, genotypes are written to standard output in GEN format."
			)
	        .set_takes_values( 1 )
			.set_maximum_multiplicity( 1 ) ;
		options[ "-sort" ]
			.set_description( "Sort the genotypes in the output file.  Currently this is only supported if BGEN, unzipped GEN, unzipped VCF format is output." ) ;
		options.option_implies_option( "-sort", "-og" ) ;

		options[ "-os" ]
	        .set_description( "Output sample information to the file specified.  " )
	        .set_takes_single_value() ;

		options[ "-o" ]
			.set_description( "Set the name of the file used to output of per-SNP, per-sample and other computations." )
			.set_takes_single_value() ;
			
		options[ "-omit-chromosome" ]
			.set_description( "(This option is specific to output files in the GEN format.) Do not output a chromosome column." ) ;

		options.option_implies_option( "-omit-chromosome", "-og" ) ;

		options.declare_group( "Pedigree file options" ) ;
		options[ "-op" ]
			.set_description( "Output a pedigree file instead of a GEN-type file."
			 	" You must also input a pedigree using -ip for this to work." )
			.set_takes_values( 1 )
			.set_maximum_multiplicity( 1 ) ;
		options[ "-ip" ]
			.set_description( "Input a pedigree from the specified file."
			 	" The first six columns of this file should represent a PED format pedigree,"
				" according to the spec on the PLINK website.  (Other columns are ignored.)"
				" Ids are treated as non-whitespace strings and sex can be either"
				" \"1\" or \"M\" (male) or \"2\" or \"F\" (female) or \"other\"." )
			.set_takes_values( 1 )
			.set_maximum_multiplicity( 1 ) ;

		options.option_implies_option( "-op", "-ip" ) ;
		options.option_implies_option( "-op", "-s" ) ;

		// VCF file options
		options.declare_group( "VCF file options" ) ;
		options[ "-vcf-genotype-field" ]
			.set_description(
				"Specify the name of the field in a VCF file to read genotypes from.  This must match "
				"the name of a FORMAT field in the VCF file."
			)
			.set_takes_single_value()
			.set_default_value( "GT" ) ;
		options[ "-metadata" ]
			.set_description(
				"Specify the name of a file containing VCF metadata to be used to parse "
				"a VCF file.  Keys in this file must either not be present in the VCF file, or must have "
				"identical values."
			)
			.set_takes_single_value() ;

		// SNP filtering options
		options.declare_group( "SNP filtering options" ) ;
		options[ "-hwe"]
			.set_description( "Filter out SNPs with -log10( HWE p-value ) greater than or equal to the value specified.")
			.set_takes_single_value() ;
		options[ "-info" ]
			.set_description( "Filter out SNPs with Fisher information lying outside the given range.")
			.set_takes_values( 2 ) ;
		options[ "-snp-missing-rate" ]
			.set_description( "Filter out SNPs with missing data rate greater than or equal to the value specified.")
			.set_takes_single_value() ;
		options[ "-missing-call-rate" ]
			.set_description( "Filter out SNPs with missing call rate greater than or equal to the value specified.")
			.set_takes_single_value() ;
		options[ "-maf" ]
			.set_description( "Filter out SNPs whose minor allele frequency lies outside the interval [a,b]." )
			.set_takes_values( 2 ) ;
		
		// Sample filtering options
		options.declare_group( "Sample filtering options" ) ;
		options[ "-sample-missing-rate" ]
			.set_description( "Filter out samples with missing data rate (as taken from the \"missing\" column of the sample file)"
			" greater than the value specified." )
			.set_takes_single_value() ;
		options[ "-heterozygosity" ]
			.set_description( "Filter out samples with heterozygosity (as taken from the \"heterozygosity\" column of the sample file, which must be present)"
				" outside the interval [a,b]." )
			.set_takes_values( 2 ) ;

		// Inclusion / exclusion list options
		options.declare_group( "Inclusion / exclusion list options" ) ;
		options[ "-write-sample-excl-list" ]
			.set_description( "Write a file containing a list of the ids of individuals which are filtered out by the sample filter." )
			.set_takes_single_value() ;
		options [ "-write-snp-excl-list" ]
			.set_description( "Write a file (or files) containing the SNPs that are filtered out." )
			.set_takes_single_value() ;
		;

		// Other options
		options.declare_group( "Other options" ) ;
		options [ "-force" ] 
			.set_description( "Ignore warnings and proceed with requested action." ) ;
		options [ "-log" ]
			.set_description( "Specify that " + globals::program_name + " should write a log file to the given file." )
			.set_takes_single_value() ;
		options [ "-threads" ]
			.set_description( "Specify the number of worker threads to use in computationally intensive tasks." )
			.set_takes_single_value()
			.set_default_value( 0 ) ;
		options [ "-buffer-snps" ]
			.set_description( "Specify that QCTOOL should buffer SNP data asynchronously in a background thread. "
				"This can improve runtimes when computations are io-bound."
			) ;
		options[ "-analysis-name" ]
			.set_description( "Specify a name to label results from this analysis with.  (This applies to modules which store their results in a qcdb file.)" )
			.set_takes_single_value()
			.set_default_value( "qctool analysis, started " + appcontext::get_current_time_as_string() ) ;
		options[ "-flat-file" ]
			.set_description( "By default, qctool outputs summary data in an sqlite database format.  This allows for more "
				"flexibility and better memory usage compared to working with flat files. "
				" This option forces qctool to use a flat file instead." )
			.set_hidden() ;

		options.declare_group( "Options for adjusting sample data" ) ;
		options[ "-quantile-normalise" ]
			.set_description( "Quantile normalise each specified continuous phenotype or covariate "
			 	"by ranking its values and mapping to quantiles of the standard normal distribution N(0,1). "
				"Ties are handled by sending tied values to the average of the corresponding quantiles."
				"The argument should be a comma-separated list of column names from the sample file." )
			.set_takes_single_value() ;
		options[ "-missing-code" ]
			.set_description( "Specify a comma-separated list of strings to be treated as missing values "
				"when encountered in the sample file(s)." )
			.set_takes_single_value()
			.set_default_value( "NA" ) ;
		options[ "-condition-on" ]
			.set_description( "Condition on the dosages of a given SNP or set of SNPs."
				" The argument should be a comma-separated list of values of the form:\n"
				"   [field]~[value]:[dose][,dose...]\n"
				"where field is \"rsid\", \"snpid\", or \"pos\", value is the value to match, and "
				"each dose is one of add,dom,het,rec,or gen."
				" If the field is omitted, it is assumed to be rsid;"
				" if the dose is omitted it is assumed to be add."
			)
			.set_takes_values( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
				
		options.option_implies_option( "-quantile-normalise", "-s" ) ;
		options.option_implies_option( "-quantile-normalise", "-os" ) ;
		options.option_implies_option( "-condition-on", "-s" ) ;
		options.option_implies_option( "-condition-on", "-os" ) ;

		//Relatotron::declare_options( options ) ;
		RelatednessComponent::declare_options( options ) ;
		DataReadTest::declare_options( options ) ;
		ClusterFitter::declare_options( options ) ;
		VCDBWriter::declare_options( options ) ;
		CallComparerComponent::declare_options( options ) ;
		ClusterPlotter::declare_options( options ) ;
		SNPSummaryComponent::declare_options( options ) ;
		SampleSummaryComponent::declare_options( options ) ;
		HaplotypeFrequencyComponent::declare_options( options ) ;

		options.option_excludes_option( "-write-sample-excl-list", "-os" ) ;

		options.option_excludes_option( "-write-snp-excl-list", "-og" ) ;

		options.option_implies_option( "-excl-samples", "-s" ) ;
		options.option_implies_option( "-incl-samples", "-s" ) ;

		options.option_implies_option( "-sample-missing-rate", "-s" ) ;
		options.option_implies_option( "-heterozygosity", "-s" ) ;
	}
} ;

struct QCToolOptionMangler {
	QCToolOptionMangler( appcontext::OptionProcessor const& options ):
		m_options( options )
	{
		process_filenames() ;
	}
	std::vector< std::string > const& input_sample_filenames() const { return m_input_sample_filenames ; }
	std::string const& output_sample_filename() const { return m_output_sample_filename ; }
	std::string const& output_sample_excl_list_filename() const { return m_output_sample_excl_list_filename ; }
	std::string const& output_sample_stats_filename() const { return m_sample_statistic_filename ; }
	std::string const log_filename() const { return m_options.get_value< std::string > ( "-log" ) ; }
	InputToOutputFilenameMapper const& gen_filename_mapper() const { return m_gen_file_mapper ; }
	std::vector< std::vector< genfile::wildcard::FilenameMatch > > const& gen_filenames() const { return m_gen_filenames ; } 
	InputToOutputFilenameMapper const& snp_excl_list_filename_mapper() const { return m_output_snp_excl_file_mapper ; }
	std::vector< std::string > row_statistics_specs() const {
		// Add default columns
		std::string column_spec = "SNPID, RSID, chromosome, position, A_allele, B_allele, minor_allele, major_allele, AA, AB, BB, AA_calls, AB_calls, BB_calls, MAF, HWE, missing, missing_calls, information, " ;
		column_spec += m_options.get_value< std::string >( "-snp-stats-old-columns" ) ;
		return string_utils::split_and_strip_discarding_empty_entries( column_spec, "," ) ;
	}
	std::vector< std::string > sample_statistics_specs() const {
		std::vector< std::string > result ;
		if( m_options.check_if_option_was_supplied( "-sample-stats-old" )) {
			result = string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-sample-stats-old-columns" ), "," ) ;
		}
		return result ;
	}
	
private:
	
	void process_filenames() {
		get_snp_related_filenames() ;
		get_sample_related_filenames() ;
	}

	void get_snp_related_filenames() {
		assert( m_options.check_if_option_was_supplied( "-g" )) ;
		std::vector< std::string > input_gen_filenames_supplied = m_options.get_values< std::string >( "-g" ) ;
		assert( input_gen_filenames_supplied.size() >= 1 ) ;
		std::string
			output_gen_filename = construct_output_gen_filename( input_gen_filenames_supplied ),
			output_snp_excl_filename = construct_output_snp_excl_list_filename( input_gen_filenames_supplied ) ;

		m_gen_file_mapper.add_filename_pair( input_gen_filenames_supplied[0], output_gen_filename ) ;
		m_output_snp_excl_file_mapper.add_filename_pair( input_gen_filenames_supplied[0], output_snp_excl_filename ) ;

		m_gen_filenames.resize( input_gen_filenames_supplied.size() ) ;
		for( std::size_t i = 0; i < input_gen_filenames_supplied.size(); ++i ) {
			m_gen_filenames[i] = genfile::wildcard::find_files_by_chromosome(
				input_gen_filenames_supplied[i],
				genfile::wildcard::eALL_CHROMOSOMES
			) ;
		}
	}

	void get_sample_related_filenames() {
		if( m_options.check_if_option_was_supplied( "-s" ) ) {
			m_input_sample_filenames = m_options.get_values< std::string >( "-s" ) ;
			assert( m_input_sample_filenames.size() == m_gen_filenames.size() ) ;
		}

		// We need to write a sample stats file if -sample-stats was given.
		if( m_options.check_if_option_was_supplied( "-sample-stats-old" ) ) {
			m_sample_statistic_filename = m_options.get_value< std::string >( "-sample-stats-old" ) ;
		}
		// Otherwise, we need to write a sample exclusion list file if -write-sample-excl-list was given.
		else if( m_options.check_if_option_was_supplied( "-write-sample-excl-list" )) {
			m_output_sample_excl_list_filename = m_options.get_value< std::string > ( "-write-sample-excl-list" ) ;
		}

		// We need to write a sample file if -os is given:
		// -os is given
		if( m_options.check_if_option_was_supplied( "-os" )) {
			m_output_sample_filename = m_options.get_value< std::string >( "-os" ) ;
		}
	}

	std::string strip_sample_file_extension_if_present( std::string filename ) {
		if( filename.size() >= 7 && filename.substr( filename.size() - 7, 7 ) == ".sample" ) {
			filename.resize( filename.size() - 7 ) ;
		}
		return filename ;
	}

	std::string construct_output_gen_filename( std::vector< std::string > const& input_gen_filenames_supplied ) {
		std::string result ;
		// We need to produce output gen files if
		//  * -og is given
		//  OR
		//  ** -write-snp-excl-list is not set
		//  * AND EITHER
		//  ** some sample filters are given (but not -write-sample-excl-list)
		//  ** OR some SNP filters are given.
		if( m_options.check_if_option_was_supplied( "-og" )
			|| (
				!( m_options.check_if_option_was_supplied( "-write-snp-excl-list" ) || m_options.check_if_option_was_supplied( "-write-snp-incl-list" ) )
				&& (
					(m_options.check_if_option_was_supplied_in_group( "Sample filtering options" ) && !m_options.check_if_option_was_supplied( "-write-sample-excl-list" ))
					||
					m_options.check_if_option_was_supplied_in_group( "SNP filtering options" )
				)
			)
		) {
			if( m_options.check_if_option_was_supplied( "-og" ) ) {
				result = m_options.get_value< std::string >( "-og" ) ;
			} else {
				assert( input_gen_filenames_supplied.size() > 0 ) ;
				std::string stub ;
				if( input_gen_filenames_supplied.size() == 1 )  {
					stub = input_gen_filenames_supplied[0] ;
				}
				else {
					stub = "qctool_cohorts_1-" + string_utils::to_string( input_gen_filenames_supplied.size() ) ;
				}
				result
					= genfile::strip_gen_file_extension_if_present( stub )
					+ ".fltrd"
					+ genfile::get_gen_file_extension_if_present( input_gen_filenames_supplied[0] ) ;
			}
		}
		return result ;
	}

	std::string construct_output_snp_excl_list_filename( std::vector< std::string > const& input_gen_filenames_supplied ) {
		std::string result ;
		if( m_options.check_if_option_was_supplied( "-write-snp-excl-list" ) ) {
				result = m_options.get_value< std::string >( "-write-snp-excl-list" ) ;
		}
		return result ;
	}

private:
	appcontext::OptionProcessor const& m_options ;
	std::vector< std::string > m_input_sample_filenames ;
	std::string m_output_sample_filename ;
	std::string m_output_sample_excl_list_filename ; 
	std::string m_sample_statistic_filename ;
	std::string m_log_filename ;
	InputToOutputFilenameMapper m_gen_file_mapper ;
	InputToOutputFilenameMapper m_output_snp_excl_file_mapper ;
	std::vector< std::vector< genfile::wildcard::FilenameMatch > > m_gen_filenames ;
} ;


struct QCToolCmdLineContext
{
	typedef genfile::SNPDataSource SNPDataSource ;
	typedef genfile::SNPDataSink SNPDataSink ;

	QCToolCmdLineContext( appcontext::OptionProcessor const& options, appcontext::UIContext& ui_context ):
		m_options( options ),
		m_mangled_options( options ),
		m_ui_context( ui_context )
	{
		try {
			setup() ;
		}
		catch( genfile::MalformedInputError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileContainsSNPsOfDifferentSizes const& ) {
			m_ui_context.logger() << "\nError: The GEN files specified did not all have the same sample size.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileNotFoundError const& e ) {
			m_ui_context.logger() << "\nError: No file matching \"" << e.filespec() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::ResourceNotOpenedError const& e ) {
			m_ui_context.logger() << "\nError: (" << e.what() << "): resource \"" << e.source() << "\" could not be opened.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch ( FileError const& e ) {
			m_ui_context.logger() << "\nFile handling exception: " << e.what() << ": relating to file \"" << e.filename() << "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch ( genfile::KeyNotFoundError const& e ) {
			m_ui_context.logger() << "\nKey \"" << e.key() << "\" was not found in source \"" << e.source() << "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch ( genfile::DuplicateKeyError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() << "): Duplicate key \"" << e.key() << "\" was found in source \"" << e.source() << "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( statfile::FileNotOpenedError const& e ) {
			m_ui_context.logger() << "\nError: No file matching \"" << e.filename() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::OperationFailedError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() << "): " << e.caller() << ": error attempting to perform the following operation on " << e.object()<< ":\n"
				<< e.operation() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::OperationUnsupportedError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() << "): " << ": the following operation on " << e.object()<< " is not supported:\n"
				<< e.operation() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	~QCToolCmdLineContext() {
		write_postamble() ;
		// Ensure a fixed deconstruction order so that samples and pedigree outlive
		// the SNP Data Sinks.
		m_fltrd_out_snp_data_sink.reset() ;
		m_fltrd_in_snp_data_sink.reset() ;
		m_cohort_individual_source.reset() ;
		m_pedigree.reset() ;
	}
	
	SNPDataSource& snp_data_source() const {
		return *m_snp_data_source ;
	}

	SNPDataSink& fltrd_in_snp_data_sink() const {
		return *m_fltrd_in_snp_data_sink ;
	}
	
	SNPDataSink& fltrd_out_snp_data_sink() const {
		return *m_fltrd_out_snp_data_sink ;
	}
	
	std::vector< SampleRow >& sample_rows() {
		return m_sample_rows ;
	}

	ObjectSink< SampleRow >& fltrd_in_sample_sink() const {
		return *m_fltrd_in_sample_sink ;
	}

	ObjectSink< SampleRow >& fltrd_out_sample_sink() const {
		return *m_fltrd_out_sample_sink ;
	}

	AndRowCondition& snp_filter() const {
		return *m_snp_filter ;
	}
	
	AndRowCondition& sample_filter() const {
		return *m_sample_filter ;
	}
	
	GenRowStatistics& snp_statistics() {
		return m_snp_statistics ;
	}

	SampleRowStatistics& sample_statistics() {
		return m_sample_statistics ;
	}
	
	std::vector< std::size_t > const& indices_of_filtered_out_samples() const { return m_indices_of_filtered_out_samples ; }

	genfile::CohortIndividualSource const& samples() const { return *m_cohort_individual_source ; }
	
	bool ignore_warnings() const {
		return m_ignore_warnings ;
	}

	std::vector< std::size_t >& snp_filter_failure_counts() { return m_snp_filter_failure_counts ; }
	std::vector< std::size_t >& sample_filter_failure_counts() { return m_sample_filter_failure_counts ; }

	void write_preamble() {
		m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;

		m_ui_context.logger() << std::setw(30) << "Input SAMPLE file(s):" ;
		for( std::size_t i = 0; i < m_mangled_options.input_sample_filenames().size(); ++i ) {
			if( i > 0 ) {
				m_ui_context.logger() << std::setw(30) << "" ;
			}
			m_ui_context.logger() << "  \"" << format_filename( m_mangled_options.input_sample_filenames()[i]) << "\"\n" ;
		}
		
		if(
			genfile::ValueMappingCohortIndividualSource const* source
				= dynamic_cast< genfile::ValueMappingCohortIndividualSource const* >( m_cohort_individual_source.get() )
		) {
			m_ui_context.logger() << std::setw(30) << "Sample file summary:" << "  " ;
			m_ui_context.logger() << source->get_summary( std::string( 32, ' ' )) << "\n" ;
		}
		
		m_ui_context.logger() << std::setw(30) << "Output SAMPLE file:"
			<< "  \"" << format_filename( m_mangled_options.output_sample_filename()) << "\".\n" ;
		m_ui_context.logger() << std::setw(30) << "Sample statistic output file:"
			<< "  \"" << format_filename( m_mangled_options.output_sample_stats_filename()) << "\".\n" ;
		m_ui_context.logger() << std::setw(30) << "Sample exclusion output file:"
			<< "  \"" << format_filename( m_mangled_options.output_sample_excl_list_filename()) << "\".\n" ;
		m_ui_context.logger() << "\n" ;

		m_ui_context.logger() << std::setw(30) << "Input GEN file(s):\n" ;
		m_ui_context.logger()<< m_snp_data_source->get_summary( "", 40 ) ;
		if( m_mangled_options.gen_filename_mapper().input_files().size() > 1 ) {
			m_ui_context.logger() << "\n" ;
		}

		m_ui_context.logger() << std::setw(30) << "Output GEN file(s):" ;
		if( m_mangled_options.gen_filename_mapper().output_filenames().empty() ) {
			m_ui_context.logger() << "  (n/a)\n" ;
		}
		else {
			for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << "\n" << std::string( 30, ' ' ) ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.gen_filename_mapper().output_filenames()[i] << "\"" ;				
			}
			m_ui_context.logger() << "\n" ;
		}

		m_ui_context.logger() << std::setw(30) << "Output SNP position file(s):" ;
		if( m_mangled_options.snp_excl_list_filename_mapper().output_filenames().empty() ) {
			m_ui_context.logger() << "  (n/a)\n" ;
		}
		else {
			for( std::size_t i = 0; i < m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << "\n" << std::string( 30, ' ' ) ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.snp_excl_list_filename_mapper().output_filenames()[i] << "\"" ;				
			}
			m_ui_context.logger() << "\n" ;
		}

		m_ui_context.logger() << std::resetiosflags( std::ios::floatfield ) << std::setprecision( 10 ) ;
		m_ui_context.logger() << std::setw(30) << "Sample filter:" 
			<< "  " << *m_sample_filter << ".\n" ;
		m_ui_context.logger() << std::setw(30) << "SNP filter:"
			<< "  " << *m_snp_filter << ".\n" ;
		m_ui_context.logger() << "\n" ;

		m_ui_context.logger() << std::setw(30) << "# of samples in input files:"
			<< "  " << m_snp_data_source->get_base_source().number_of_samples() << ".\n" ;
		m_ui_context.logger() << std::setw(30) << "# of samples after filtering:"
			<< "  " << m_snp_data_source->number_of_samples()
			<< " (" << m_indices_of_filtered_out_samples.size()
			<< " filtered out).\n" ;

		m_ui_context.logger() << "\n" << std::string( 72, '=' ) << "\n\n" ;

		if( !m_errors.empty() ) {
			for( std::size_t i = 0; i < m_errors.size(); ++i ) {
				m_ui_context.logger() << "!! ERROR: " << m_errors[i] << "\n\n" ;
			}
			m_ui_context.logger() << "!! Please correct the above errors and re-run qctool.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}

		if( !m_warnings.empty() ) {
			for( std::size_t i = 0; i < m_warnings.size(); ++i ) {
				m_ui_context.logger() << "!! WARNING: " << m_warnings[i] << "\n\n" ;
			}
			if( m_ignore_warnings ) {
				m_ui_context.logger() << "!! Warnings were encountered, but proceeding anyway as -force was supplied.\n" ;
				m_ui_context.logger() << "\n" << std::string( 72, '=' ) << "\n\n" ;
			}
			else {
				m_ui_context.logger() << "!! Warnings were encountered.  To proceed anyway, please run again with the -force option.\n" ;
				throw appcontext::HaltProgramWithReturnCode( -1 ) ;
			}
		}
		
	}
	
	std::string format_filename( std::string const& filename ) {
		if( filename == "" ) {
			return "(n/a)" ;
		}
		else {
			return filename ;
		}
	}
	
	void write_postamble() {
		m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;
		if( m_backup_creator.backed_up_files().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "I took backups of the following files before overwriting:\n" ;
			std::size_t max_length = 0u ;
			for(
				std::map< std::string, std::string >::const_iterator i = m_backup_creator.backed_up_files().begin() ;
				i != m_backup_creator.backed_up_files().end() ;
				++i
			) {
				max_length = std::max( max_length, i->first.size() ) ;
			}

			for(
				std::map< std::string, std::string >::const_iterator i = m_backup_creator.backed_up_files().begin() ;
				i != m_backup_creator.backed_up_files().end() ;
				++i
			) {
				m_ui_context.logger() << "  " << std::setw( max_length + 2 ) << std::left << ("\"" + i->first + "\"") << " to \"" << i->second << "\"\n" ;
			}

			m_ui_context.logger() << "\n" ;
			m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;
		}

		m_ui_context.logger() << std::setw(36) << "Number of SNPs:\n"
			<< std::setw(36) << " -- in input file(s):" ;
		if( m_snp_data_source->total_number_of_snps() ) {
			m_ui_context.logger() << "  " << *m_snp_data_source->total_number_of_snps() << ".\n" ;
		}
		else {
			m_ui_context.logger() << "  " << "(not computed).\n" ;
		}
		
		m_ui_context.logger() << std::setw(36) << " -- in output file(s):"
			<< "  " << m_fltrd_in_snp_data_sink->number_of_snps_written() << "\n" ;

		if( m_snp_filter->number_of_subconditions() > 0 ) {
			m_ui_context.logger() << std::resetiosflags( std::ios::floatfield ) ;
			for( std::size_t i = 0; i < m_snp_filter->number_of_subconditions(); ++i ) {
				m_ui_context.logger() << std::setw(36) << ("...which failed \"" + string_utils::to_string( m_snp_filter->subcondition( i )) + "\":")
					<< "  " << m_snp_filter_failure_counts[i] << ".\n" ;
			}

			m_ui_context.logger() << std::setw(36) << "(total failures:"
				<< "  " << m_fltrd_out_snp_data_sink->number_of_snps_written() << ").\n" ;
		}
		
		m_ui_context.logger() << "\n" ;

		m_ui_context.logger() << std::setw(36) << "Number of samples in input file(s):"
			<< "  " << m_snp_data_source->get_base_source().number_of_samples() << ".\n" ;
		if( m_sample_filter->number_of_subconditions() > 0 ) {
			for( std::size_t i = 0 ; i < m_sample_filter_failure_counts.size(); ++ i ) {
				m_ui_context.logger() << std::setw(36) << ("...which failed \"" + string_utils::to_string( m_sample_filter->subcondition( i )) + "\":")
					<< "  " << m_sample_filter_failure_counts[i] << ".\n" ;
			}
			m_ui_context.logger() << std::setw(36) << "(total failures:" << "  " << m_indices_of_filtered_out_samples.size() << ").\n" ;
		}

		m_ui_context.logger() << "\n" ;

		if( m_mangled_options.output_sample_excl_list_filename() != "" ) {
			m_ui_context.logger() << std::setw(36) << "Output sample exclusion list:"
				<< " " << m_mangled_options.output_sample_excl_list_filename() << " ("
				<< m_indices_of_filtered_out_samples.size() << " samples).\n" ;
		}

		if( m_mangled_options.gen_filename_mapper().output_filenames().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "Output GEN files:" ;
			for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << std::string( 36, ' ' ) ;
				}
				if( m_fltrd_in_snp_data_sink.get() ) {
					m_ui_context.logger() << "  (" << std::setw(6) << m_fltrd_in_snp_data_sink->sink(i).number_of_snps_written() << " snps)  " ;
				}
				m_ui_context.logger() << "\"" << m_mangled_options.gen_filename_mapper().output_filenames()[i] << "\"\n" ;
			}
			m_ui_context.logger() << std::string( 36, ' ' ) << "  (total " << m_fltrd_in_snp_data_sink->number_of_snps_written() << " snps).\n" ;
		}
		
		if( m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "Output SNP exclusion list(s):" ;
			for( std::size_t i = 0; i < m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << std::string( 36, ' ' ) ;
				}
				if( m_fltrd_out_snp_data_sink.get() ) {
					m_ui_context.logger() << "  (" << std::setw(6) << m_fltrd_out_snp_data_sink->sink(i).number_of_snps_written() << " snps)  " ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.snp_excl_list_filename_mapper().output_filenames()[i] << "\"\n" ;				
			}
			m_ui_context.logger() << std::string( 36, ' ' ) << "  (total " << m_fltrd_out_snp_data_sink->number_of_snps_written() << " snps).\n" ;
		}
		
		if( m_mangled_options.output_sample_filename() != "" ) {
			m_ui_context.logger() << std::setw(36) << "Output SAMPLE files:"
				<< "  \"" << m_mangled_options.output_sample_filename() << "\""
				<< "  (" << m_sample_rows.size() << " samples)\n" ;
		}
		if( m_mangled_options.output_sample_stats_filename() != "" ) {
			m_ui_context.logger() << std::setw(36) << "Sample statistic output file:"
				<< "  \"" << m_mangled_options.output_sample_stats_filename() << "\".\n" ;
		}

		if( m_options.check( "-log" )) {
			m_ui_context.logger()[ "screen" ] << std::setw( 36 ) << "\nMore details are in the log file:"
				<< "  \"" << m_mangled_options.log_filename() << "\".\n" ;
		}
		m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;
	}

	genfile::CohortIndividualSource const& get_cohort_individual_source() const { assert( m_cohort_individual_source.get() ) ; return *m_cohort_individual_source ; }

private:
	appcontext::OptionProcessor const& m_options ;
	QCToolOptionMangler const m_mangled_options ;
	appcontext::UIContext& m_ui_context ;

	typedef std::map< genfile::SNPIdentifyingData, genfile::SNPIdentifyingData > SNPDictionary ;
	std::auto_ptr< SNPDictionary > m_snp_dictionary ;

	typedef std::map< genfile::SNPIdentifyingData, char > StrandSpec ;
	typedef std::vector< StrandSpec > StrandSpecs ;
	std::auto_ptr< StrandSpecs > m_strand_specs ;
	genfile::Pedigree::UniquePtr m_pedigree ;	// this must go before snp_data_sinks.
	genfile::CohortIndividualSource::UniquePtr m_cohort_individual_source ; // this must go before the snp_data_sinks.
	std::auto_ptr< genfile::SNPDataSource > m_snp_data_source ;
	std::auto_ptr< genfile::SNPDataSinkChain > m_fltrd_in_snp_data_sink ;
	std::auto_ptr< genfile::SNPDataSinkChain > m_fltrd_out_snp_data_sink ;
	std::auto_ptr< ObjectSource< SampleRow > > m_sample_source ;

	std::vector< SampleRow > m_sample_rows ;

	std::auto_ptr< ObjectSink< SampleRow > > m_fltrd_in_sample_sink ;
	std::auto_ptr< ObjectSink< SampleRow > > m_fltrd_out_sample_sink ;
	std::auto_ptr< statfile::BuiltInTypeStatSink > m_snp_stats_sink ;
	std::auto_ptr< statfile::BuiltInTypeStatSink > m_sample_stats_sink ;

	std::vector< std::size_t > m_snp_filter_failure_counts ;
	std::vector< std::size_t > m_sample_filter_failure_counts ;
	
	bool m_ignore_warnings ; 
	
	std::size_t m_current_snp_stats_filename_index ;

	std::auto_ptr< AndRowCondition > m_snp_filter ;
	std::auto_ptr< AndRowCondition > m_sample_filter ;

	GenRowStatistics m_snp_statistics ;
	SampleRowStatistics m_sample_statistics ;
	
	std::vector< std::size_t > m_indices_of_filtered_out_samples ;
	
	ToNumberedFileBackupCreator m_backup_creator ;
	
	std::vector< std::string > m_warnings ;
	std::vector< std::string > m_errors ;
	
private:
	
	void setup() {
		construct_snp_filter() ;
		construct_sample_filter() ;
		process_other_options() ;
		
		if( m_options.check_if_option_has_value( "-translate-snp-positions" )) {
			m_snp_dictionary = load_snp_dictionary( m_options.get_value< std::string >( "-translate-snp-positions" ) ) ;
		}

		if( m_options.check_if_option_has_value( "-strand" )) {
			m_strand_specs = get_strand_specs( m_options.get_values< std::string >( "-strand" )) ;
		}
		
		m_snp_data_source = open_snp_data_sources(
			m_mangled_options.gen_filenames(),
			m_options.check( "-match-alleles-to-cohort1" )
		) ;
		
		{
			m_cohort_individual_source = open_samples( m_snp_data_source->number_of_samples() ) ;
		
			if( m_options.check( "-condition-on" )) {
				m_cohort_individual_source = condition_on(
					m_cohort_individual_source,
					*m_snp_data_source,
					genfile::string_utils::join( m_options.get_values< std::string >( "-condition-on" ), "," )
				) ;
				m_snp_data_source->reset_to_start() ;
			}
			load_sample_rows( m_cohort_individual_source ) ;
		}

		if( m_indices_of_filtered_out_samples.size() > 0 ) {
			m_snp_data_source.reset(
				new genfile::SampleFilteringSNPDataSource(
					m_snp_data_source,
					std::set< std::size_t >( m_indices_of_filtered_out_samples.begin(), m_indices_of_filtered_out_samples.end() )
				)
			) ;
			
			if( m_cohort_individual_source.get() ) {
				m_cohort_individual_source.reset(
					genfile::SampleFilteringCohortIndividualSource::create(
						m_cohort_individual_source,
						std::set< std::size_t >( m_indices_of_filtered_out_samples.begin(), m_indices_of_filtered_out_samples.end() )
					).release()
				) ;
			}
		}
		
		if( m_options.check( "-merge-in" )) {
			m_snp_data_source = open_merged_data_sources() ;
		}

		if( m_options.check( "-buffer-snps" ) ) {
			m_snp_data_source.reset(
				new genfile::AsynchronousSNPDataSource( m_snp_data_source )
			) ;
		}
	
		check_for_errors_and_warnings() ;

		write_preamble() ;
		
		open_sample_row_sink() ;
		open_snp_data_sinks() ;
	}
	
	std::auto_ptr< StrandSpecs > get_strand_specs( std::vector< std::string > const& filenames ) const {
		std::auto_ptr< StrandSpecs > result( new StrandSpecs( filenames.size() ) ) ;
		
		appcontext::UIContext::ProgressContext progress_context = m_ui_context.get_progress_context( "Loading strand files" ) ;
		progress_context.notify_progress( 0, filenames.size() ) ;
		
		std::vector< std::pair< int, int > > summaries( filenames.size(), std::make_pair( 0, 0 ) ) ; // first = row count, second = failure count.
		
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			statfile::BuiltInTypeStatSource::UniquePtr source( statfile::BuiltInTypeStatSource::open( filenames[i] )) ;
			if( source->number_of_columns() < 6 ) {
				throw genfile::MalformedInputError( filenames[i], 1 ) ;
			}

			std::string platform_column_names ;
			if( source->has_column( "Affy SNP ID" )) {
				platform_column_names = "Chromosome|Physical Position|Probe Set ID|dbSNP RS ID|Allele A|Allele B|Strand" ;
			}
			else if( source->has_column( "IlmnID" )) {
				platform_column_names = "Chromosome|position|IlmnID|rsid|alleleA|alleleB|strand" ;
			}
			else if( source->has_column( "SNPID" ) ) {
				if( source->index_of_column( "SNPID" ) == 2 && source->has_column( "rsid" ) && source->index_of_column( "rsid" ) == 3 ) {
					platform_column_names = "chromosome|position|SNPID|rsid|alleleA|alleleB|strand" ;
				}
				else {
					throw genfile::MalformedInputError( source->get_source_spec(), 0 ) ;
				}
			}
			else {
				throw genfile::MalformedInputError( source->get_source_spec(), 0 ) ;
			}

			summaries[i].first = source->number_of_rows() ; // row count.

			while( *source ) {
				genfile::SNPIdentifyingData snp ;
				std::string strand ;
				try {
					if(
						statfile::read_values(
							*source,
							platform_column_names,
							boost::tie(
								snp.position().chromosome(),
								snp.position().position(),
								snp.SNPID(),
								snp.rsid(),
								snp.first_allele(),
								snp.second_allele(),
								strand
							)
						)
					) {
						// Support illumina "FWD" and "REV" strands.
						if( strand == "REV" || strand == "-" ) {
							strand = genfile::StrandAligningSNPDataSource::eReverseStrand ;
						}
						else if( strand == "FWD" || strand == "+" ) {
							strand = genfile::StrandAligningSNPDataSource::eForwardStrand ;
						}
						else if( strand == "?" || strand == "NA" ) {
							// std::cerr << "strand = ?: SNP is " << snp << ".\n" ;
							strand = genfile::StrandAligningSNPDataSource::eUnknownStrand ;
						}
						else {
							m_ui_context.logger() << "!! Error: found unrecognised strand \"" << strand << "\" in strand alignment file.\n" ;
							throw genfile::MalformedInputError( source->get_source_spec(), source->number_of_rows_read() + 1 ) ;
						}
				
						StrandSpec::iterator where = result->at(i).find( snp ) ;
						if( where != result->at(i).end() ) {
							throw genfile::DuplicateKeyError( source->get_source_spec(), genfile::string_utils::to_string( snp ) ) ;
						}
						result->at(i)[ snp ] = strand[0] ;
						(*source) >> statfile::ignore_all() ;
					}
				}
				catch( genfile::InputError ) {
					++summaries[i].second ; // failure count
					(*source) >> statfile::ignore_all() ;
				}
			}
			assert( source->number_of_rows_read() == source->number_of_rows() ) ;

			progress_context.notify_progress( i+1, filenames.size() ) ;
		}
		
		m_ui_context.logger() << "\nStrand file summary:\n" ;
		for( std::size_t i = 0; i < summaries.size(); ++i ) {
			m_ui_context.logger() << std::setw( 30) << ( "  \"" + filenames[i] + "\"" ) << ": " << std::setw( 7 ) << summaries[i].first << " rows" ;
			if( summaries[i].second > 0 ) {
				m_ui_context.logger() << " of which " << summaries[i].second << " may be malformed, and will be ignored" ;
			}
			m_ui_context.logger() << ".\n" ;
		}
		
		return result ;
	}
	
public:
	genfile::SNPDataSource::UniquePtr open_snp_data_sources(
		std::vector< genfile::wildcard::FilenameMatch > const& filenames
	) const {
		return open_snp_data_sources(
			std::vector< std::vector< genfile::wildcard::FilenameMatch > >( 1, filenames ),
			false
		) ;
	}

private:
	genfile::SNPDataSource::UniquePtr open_snp_data_sources(
		std::vector< std::vector< genfile::wildcard::FilenameMatch > > const& filenames,
		bool match_alleles_between_cohorts
	) const {
		genfile::SNPDataSourceRack::UniquePtr rack ;
		if( filenames.size() > 1 ) {
			rack.reset( new genfile::SNPDataSourceRack( m_options.get_value< std::string >( "-snp-match-fields" ) ) ) ;
		}

		// count files.
		std::size_t file_count = 0 ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			file_count += filenames[i].size() ;
		}

		appcontext::UIContext::ProgressContext progress_context = m_ui_context.get_progress_context( "Opening genotype files" ) ;
		progress_context.notify_progress( 0, file_count ) ;

		std::size_t progress_count = 0 ;

		genfile::SNPDataSource::UniquePtr source ;

		std::vector< genfile::SNPIdentifyingData > cohort1_snps ;
		
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			genfile::SNPDataSourceChain::UniquePtr chain( new genfile::SNPDataSourceChain() ) ;

			for( std::size_t j = 0; j < filenames[i].size(); ++j ) {
				source = open_snp_data_source(
					filenames[i][j].filename(),
					filenames[i][j].match()
				) ;

				// Add the source to the chain.
				chain->add_source( genfile::SNPDataSource::UniquePtr( source ) ) ;

				progress_context.notify_progress( ++progress_count, file_count ) ;
			}

			std::vector< genfile::SNPIdentifyingData > snps ;
			// Do we need a list of SNPs?
			if( m_strand_specs.get() ||  m_options.check_if_option_was_supplied( "-match-alleles-to-cohort1" )) {
				snps = genfile::get_list_of_snps_in_source( *chain ) ;
			}

			source.reset( chain.release() ) ;
			
			// If we have strand alignment information, implement it now
			if( m_strand_specs.get() ) {
				assert( m_strand_specs->size() == filenames.size() ) ;
				genfile::StrandAligningSNPDataSource::StrandAlignments strand_alignments ;
				boost::tie( snps, strand_alignments ) = genfile::StrandAligningSNPDataSource::create_strand_alignments(
					snps,
					m_strand_specs->at(i)
				) ;
				source.reset(
					genfile::StrandAligningSNPDataSource::create(
						source,
						strand_alignments
					)
					.release()
				) ;
			}

			if( match_alleles_between_cohorts ) {
				if( i == 0 ) {
					cohort1_snps = snps ;
				}
				else {
					genfile::AlleleFlippingSNPDataSource::AlleleFlipSpec allele_flip_spec ;
					boost::tie( snps, allele_flip_spec ) = genfile::AlleleFlippingSNPDataSource::get_allele_flip_spec(
						cohort1_snps,
						snps,
						genfile::SNPIdentifyingData::CompareFields(
							m_options.get_value< std::string >( "-snp-match-fields" ) + ",alleles"
						)
					) ;
				
					source.reset(
						genfile::AlleleFlippingSNPDataSource::create(
							source,
							allele_flip_spec
						)
						.release()
					) ;
				}
			}
			
			if( rack.get() ) {
				rack->add_source( source ) ;
			} else {
				break ;
			}
		}
		
		if( rack.get() ) {
			source.reset( rack.release() ) ;
		}

		source->reset_to_start() ;
		return source ;
	}
	
	genfile::SNPDataSource::UniquePtr open_merged_data_sources() {
		genfile::MergingSNPDataSource::UniquePtr merged_source = genfile::MergingSNPDataSource::create( m_options.get< std::string >( "-merge-strategy" )) ;
		merged_source->add_source( m_snp_data_source ) ;
		std::vector< std::string > merge_in_files = m_options.get_values< std::string >( "-merge-in" ) ;
		std::string id_prefix = "" ;
		if( m_options.check( "-merge-prefix" )) {
			id_prefix = m_options.get< std::string >( "-merge-prefix" ) ;
		}

		for( std::size_t i = 0; i < merge_in_files.size(); ++i ) {
			genfile::SNPDataSource::UniquePtr source = genfile::SNPDataSource::create_chain(
				genfile::wildcard::find_files_by_chromosome( merge_in_files[i] )
			) ;
			
			// Make the merged-in source respect the filter.
			genfile::CommonSNPFilter::UniquePtr snp_filter = get_snp_exclusion_filter() ;
			if( snp_filter.get() ) {
				std::vector< genfile::SNPIdentifyingData > snps = genfile::get_list_of_snps_in_source( *source ) ;
				
				std::vector< std::size_t > indices_of_filtered_in_snps = snp_filter->get_indices_of_filtered_in_snps( snps ) ;
				source.reset(
					genfile::SNPFilteringSNPDataSource::create(
						source,
						indices_of_filtered_in_snps
					).release()
				) ;
			}
			
			merged_source->add_source(
				source,
				id_prefix + ":"
			) ;
		}

		return genfile::SNPDataSource::UniquePtr( merged_source.release() ) ;
	}
	
	void write_excluded_SNP( genfile::SNPIdentifyingData const& snp ) const {
		if( m_fltrd_out_snp_data_sink.get() ) {
			Eigen::MatrixXd matrix( m_cohort_individual_source->get_number_of_individuals(), 3 ) ;
			matrix.setZero() ;
			m_fltrd_out_snp_data_sink->write_snp(
				m_cohort_individual_source->get_number_of_individuals(),
				snp,
				genfile::GenotypeGetter< Eigen::MatrixXd >( matrix, 0 ),
				genfile::GenotypeGetter< Eigen::MatrixXd >( matrix, 1 ),
				genfile::GenotypeGetter< Eigen::MatrixXd >( matrix, 2 )
			) ;
		}
	}
	
	genfile::SNPDataSource::UniquePtr
	open_snp_data_source( std::string const& filename, std::string chromosome_indicator ) const {
		if( chromosome_indicator == "" && m_options.check_if_option_was_supplied( "-assume-chromosome" )) {
			chromosome_indicator = m_options.get_value< std::string >( "-assume-chromosome" ) ;
		}

		genfile::SNPDataSource::UniquePtr source ;

		std::pair< std::string, std::string > uf = genfile::uniformise( filename ) ;

		if( uf.first == "vcf" ) {
			source = open_vcf_format_snp_data_source( uf ) ;
		}
		else {
			genfile::vcf::MetadataParser::Metadata metadata ;
			if( m_options.check( "-metadata" )) {
				metadata = genfile::vcf::StrictMetadataParser(
					m_options.get_value< std::string >( "-metadata" )
				).get_metadata() ;
			}
			if( m_options.check( "-filetype" )) {
				source = genfile::SNPDataSource::create(
					filename,
					chromosome_indicator,
					metadata,
					m_options.get< std::string >( "-filetype" )
				) ;
			} else {
				source = genfile::SNPDataSource::create(
					filename,
					chromosome_indicator,
					metadata
				) ;
			}
		}

		genfile::CommonSNPFilter::UniquePtr snp_filter = get_snp_exclusion_filter() ;
		// Filter SNPs if necessary
		if( snp_filter.get() ) {
			genfile::SNPIdentifyingDataFilteringSNPDataSource::UniquePtr snp_filtering_source
				= genfile::SNPIdentifyingDataFilteringSNPDataSource::create(
					source,
					genfile::SNPIdentifyingDataTest::UniquePtr( snp_filter.release() )
				) ;

			if( m_options.check( "-write-snp-excl-list" )) {
				snp_filtering_source->send_filtered_out_SNPs_to(
					boost::bind(
						&QCToolCmdLineContext::write_excluded_SNP,
						this,
						_1
					)
				) ;
			}
		
			source.reset(
				snp_filtering_source.release()
			) ;
		}
		
		// Translate SNP identifying data if necessary
		if( m_snp_dictionary.get() ) {
			source.reset(
				genfile::SNPTranslatingSNPDataSource::create(
					source,
					*m_snp_dictionary
				).release()
			) ;
		}

		return source ;
	}
	
	genfile::SNPDataSource::UniquePtr
	open_vcf_format_snp_data_source( std::pair< std::string, std::string > const& uf ) const {
		genfile::VCFFormatSNPDataSource::UniquePtr source ;
		if( m_options.check_if_option_was_supplied( "-metadata" )) {
			source.reset(
				new genfile::VCFFormatSNPDataSource(
					uf.second,
					genfile::vcf::StrictMetadataParser(
						m_options.get_value< std::string >( "-metadata" )
					).get_metadata()
				)
			) ;
		}
		else {
			source.reset(
				new genfile::VCFFormatSNPDataSource(
					uf.second
				)
			) ;
		}
		
		std::string genotype_field = m_options.get< std::string >( "-vcf-genotype-field" ) ;
		source->set_field_mapping( "genotypes", genotype_field ) ;
		
		return genfile::SNPDataSource::UniquePtr( source.release() ) ;
	}
	
	std::auto_ptr< SNPDictionary > load_snp_dictionary( std::string const& filename ) const {
		std::auto_ptr< SNPDictionary > result( new SNPDictionary ) ;
		statfile::BuiltInTypeStatSource::UniquePtr source( 
			statfile::BuiltInTypeStatSource::open(
				genfile::wildcard::find_files_by_chromosome( filename )
			).release()
		) ;
		
		appcontext::UIContext::ProgressContext progress_context = m_ui_context.get_progress_context( "Opening position translation dictionary" ) ;
		
		if( !source->number_of_columns() == 10 ) {
			throw genfile::MalformedInputError( filename, 1 ) ;
		}
		
		genfile::SNPIdentifyingData data1, data2 ;
		while(
			(*source)
				>> data1.SNPID() >> data1.rsid()
				>> data1.position().chromosome() >> data1.position().position()
				>> data1.first_allele() >> data1.second_allele()
				>> data2.SNPID() >> data2.rsid()
				>> data2.position().chromosome() >> data2.position().position()
				>> data2.first_allele() >> data2.second_allele()
		) {
			std::map< genfile::SNPIdentifyingData, genfile::SNPIdentifyingData >::const_iterator where = result->find( data1 ) ;
			if( where != result->end() ) {
				throw genfile::DuplicateSNPError( filename, genfile::string_utils::to_string( data1 ) ) ;
			}
			(*result)[ data1 ] = data2 ;
			(*source) >> statfile::end_row() ;
			progress_context( source->number_of_rows_read(), source->number_of_rows() ) ;
		}
		return result ;
	}
		
	genfile::CommonSNPFilter::UniquePtr get_snp_exclusion_filter() const {
		genfile::CommonSNPFilter::UniquePtr snp_filter ;

		if( m_options.check_if_option_was_supplied_in_group( "SNP exclusion options" )) {
			snp_filter.reset( new genfile::CommonSNPFilter ) ;

			if( m_options.check_if_option_was_supplied( "-excl-snps" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-excl-snps" ) ;
				
				BOOST_FOREACH( std::string const& filename, files ) {
					genfile::SNPDataSource::UniquePtr source ;
					try {
						source = genfile::SNPDataSource::create_chain( genfile::wildcard::find_files_by_chromosome( filename ) ) ;
					}
					catch( genfile::MalformedInputError const& e ) {
						source.reset(
							new statfile::SNPDataSourceAdapter(
								statfile::BuiltInTypeStatSource::open(
									genfile::wildcard::find_files_by_chromosome( filename )
								)
							)
						) ;
					}
						
					snp_filter->exclude_snps(
						source->list_snps(),
						genfile::SNPIdentifyingData::CompareFields( m_options.get_value< std::string >( "-snp-match-fields" ) )
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-incl-snps" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-incl-snps" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					genfile::SNPDataSource::UniquePtr source ;
					try {
						source = genfile::SNPDataSource::create_chain( genfile::wildcard::find_files_by_chromosome( filename ) ) ;
					}
					catch( genfile::MalformedInputError const& e ) {
						source.reset(
							new statfile::SNPDataSourceAdapter(
								statfile::BuiltInTypeStatSource::open(
									genfile::wildcard::find_files_by_chromosome( filename )
								)
							)
						) ;
					}
					snp_filter->include_snps(
						source->list_snps(),
						genfile::SNPIdentifyingData::CompareFields( m_options.get_value< std::string >( "-snp-match-fields" ) )
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-excl-snpids" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-excl-snpids" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					snp_filter->exclude_snps_in_file(
						filename,
						genfile::CommonSNPFilter::SNPIDs
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-incl-snpids" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-excl-snpids" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					snp_filter->include_snps_in_file(
						filename,
						genfile::CommonSNPFilter::SNPIDs
					) ;
				}
			}


			if( m_options.check_if_option_was_supplied( "-excl-rsids" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-excl-rsids" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					snp_filter->exclude_snps_in_file(
						filename,
						genfile::CommonSNPFilter::RSIDs
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-incl-rsids" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-incl-rsids" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					snp_filter->include_snps_in_file(
						filename,
						genfile::CommonSNPFilter::RSIDs
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-excl-positions" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-excl-positions" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					snp_filter->exclude_snps_in_file(
						filename,
						genfile::CommonSNPFilter::Positions
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-incl-positions" )) {
				std::vector< std::string > files = m_options.get_values< std::string > ( "-incl-positions" ) ;
				BOOST_FOREACH( std::string const& filename, files ) {
					snp_filter->include_snps_in_file(
						filename,
						genfile::CommonSNPFilter::Positions
					) ;
				}
			}
			if( m_options.check_if_option_was_supplied( "-excl-snps-matching" )) {
				std::string it = m_options.get< std::string > ( "-excl-snps-matching" ) ;
				std::vector< std::string > specs = genfile::string_utils::split_and_strip_discarding_empty_entries( it, ",", " " ) ;
				BOOST_FOREACH( std::string const& spec, specs ) {
					snp_filter->exclude_snps_matching(
						spec
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-incl-snps-matching" )) {
				std::string it = m_options.get< std::string > ( "-incl-snps-matching" ) ;
				std::vector< std::string > specs = genfile::string_utils::split_and_strip_discarding_empty_entries( it, ",", " " ) ;
				BOOST_FOREACH( std::string const& spec, specs ) {
					snp_filter->include_snps_matching(
						spec
					) ;
				}
			}
			
			if( m_options.check_if_option_was_supplied( "-incl-range" )) {
				std::vector< std::string > specs = genfile::string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-incl-range" ), ",", " \t" ) ;
				for ( std::size_t i = 0; i < specs.size(); ++i ) {
					snp_filter->include_snps_in_range(
						genfile::GenomePositionRange::parse( specs[i] )
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-excl-range" )) {
				std::vector< std::string > specs = genfile::string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-excl-range" ), ",", " \t" ) ;
				for ( std::size_t i = 0; i < specs.size(); ++i ) {
					snp_filter->exclude_snps_in_range(
						genfile::GenomePositionRange::parse( specs[i] )
					) ;
				}
			}
		}
		return snp_filter ;
	}
	
	void move_to_next_output_file( std::size_t index ) {
		// Kludge: don't move through outputs until they are actually created.
		// Actually, we only want to move through outputs once during the main
		// processing, but for example id filtering takes place first and has nothing
		// to do with the outputs. On the other hand, filtering should probably
		// happen before the
		if( m_fltrd_in_snp_data_sink.get() ) {
			if( index < m_mangled_options.gen_filename_mapper().input_files().size() ) {
				if( m_mangled_options.gen_filename_mapper().output_filenames().size() > 0 ) {
					if( m_mangled_options.gen_filename_mapper().filename_corresponding_to( index ) != m_fltrd_in_snp_data_sink->index_of_current_sink() ) {
						m_fltrd_in_snp_data_sink->move_to_next_sink() ;
					}
				}
				
				if( m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() > 0 ) {
					if( m_mangled_options.snp_excl_list_filename_mapper().filename_corresponding_to( index ) != m_fltrd_out_snp_data_sink->index_of_current_sink() ) {
						m_fltrd_out_snp_data_sink->move_to_next_sink() ;
					}
				}
			}
		}
	}

	void open_snp_data_sinks() {
		open_filtered_in_snp_data_sink() ;
		open_filtered_out_snp_data_sink() ;
	}

	void reset_filtered_in_snp_data_sink() {
		m_fltrd_in_snp_data_sink = std::auto_ptr< genfile::SNPDataSinkChain >( new genfile::SNPDataSinkChain() ) ;
	}

	void open_filtered_in_snp_data_sink() {
		reset_filtered_in_snp_data_sink() ;
		if( m_options.check_if_option_was_supplied( "-op" )) {
			assert( m_options.check_if_option_was_supplied( "-ip" )) ;
			assert( !m_options.check_if_option_was_supplied( "-og" )) ;
			
			m_pedigree = genfile::Pedigree::create(
				"file:" + m_options.get_value< std::string >( "-ip" )
			) ;

			std::string filename = m_options.get_value< std::string >( "-op" ) ;
			if( filename.size() > 4 && filename.substr( filename.size() - 4, 4 ) == ".bed" ) {
				m_fltrd_in_snp_data_sink->add_sink(
					genfile::SNPDataSink::UniquePtr(
						new genfile::BedFileSNPDataSink(
							*m_cohort_individual_source,
							*m_pedigree,
							filename
						)
					)
				) ;
			}
			else {
				m_fltrd_in_snp_data_sink->add_sink(
					genfile::SNPDataSink::UniquePtr(
						new genfile::PedFileSNPDataSink(
							*m_cohort_individual_source,
							*m_pedigree,
							filename
						)
					)
				) ;
			}
		}
		else if( m_mangled_options.gen_filename_mapper().output_filenames().size() == 0 ) {
			m_fltrd_in_snp_data_sink->add_sink( genfile::SNPDataSink::UniquePtr( new genfile::TrivialSNPDataSink() )) ;
		}
		else {
			for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++i ) {
				std::string const& filename = m_mangled_options.gen_filename_mapper().output_filenames()[i] ;
				genfile::SNPDataSink::UniquePtr sink = genfile::SNPDataSink::create( filename ) ;
				if( m_options.check_if_option_was_supplied( "-omit-chromosome" )) {
					genfile::GenFileSNPDataSink* gen_sink = dynamic_cast< genfile::GenFileSNPDataSink* >( sink.get() ) ;
					if( gen_sink ) {
						gen_sink->omit_chromosome() ;
					}
				}
				if( m_options.check( "-sort" )) {
					sink.reset(
						new genfile::SortingBGenFileSNPDataSink( filename, sink )
					) ;
				}
				m_fltrd_in_snp_data_sink->add_sink( sink ) ;
			}
		}
	}

	void open_filtered_out_snp_data_sink() {
		reset_filtered_out_snp_data_sink() ;
		if( m_options.check_if_option_was_supplied( "-write-snp-excl-list" ) && m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() > 0 ) {
			for( std::size_t i = 0; i < m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size(); ++i ) {
				std::string const& filename = m_mangled_options.snp_excl_list_filename_mapper().output_filenames()[i] ;
				m_fltrd_out_snp_data_sink->add_sink( genfile::SNPDataSink::UniquePtr( new SNPIDSink( filename ))) ;
			}
		}
		else {
			m_fltrd_out_snp_data_sink->add_sink( genfile::SNPDataSink::UniquePtr( new genfile::TrivialSNPDataSink() )) ;
		}
	}

	void reset_filtered_out_snp_data_sink() {
		m_fltrd_out_snp_data_sink.reset( new genfile::SNPDataSinkChain() ) ;
	}

	void open_sample_row_sink() {
		m_fltrd_in_sample_sink.reset( new NullObjectSink< SampleRow >() ) ;
		if( m_mangled_options.output_sample_filename() != "" ) {
			m_backup_creator.backup_file_if_necessary( m_mangled_options.output_sample_filename() ) ;
			m_fltrd_in_sample_sink.reset( new SampleOutputFile< SimpleFileObjectSink< SampleRow > >( open_file_for_output( m_mangled_options.output_sample_filename() ))) ;
		}
		
		m_fltrd_out_sample_sink.reset( new NullObjectSink< SampleRow >() ) ;
		if( m_mangled_options.output_sample_excl_list_filename() != "" ) {
			m_fltrd_out_sample_sink.reset( new SampleIDSink( m_mangled_options.output_sample_excl_list_filename() )) ;
		}
	}

	void construct_snp_filter() {
		std::auto_ptr< AndRowCondition > snp_filter( new AndRowCondition() ) ;

		if( m_options.check_if_option_was_supplied( "-hwe" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *snp_filter, "HWE", m_options.get_value< double >( "-hwe" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-info" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *snp_filter, "information", m_options.get_values< double >( "-info" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-snp-missing-rate" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *snp_filter, "missing", m_options.get_value< double >( "-snp-missing-rate" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-snp-missing-call-rate" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *snp_filter, "missing_calls", m_options.get_value< double >( "-snp-missing-call-rate" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-maf" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *snp_filter, "MAF", m_options.get_values< double >( "-maf" )) ;
		}

		m_snp_filter = snp_filter ;
		m_snp_filter_failure_counts.resize( m_snp_filter->number_of_subconditions(), 0 ) ;
	}

	void construct_sample_filter() {
		std::auto_ptr< AndRowCondition > sample_filter( new AndRowCondition() ) ;
		
		if( m_options.check_if_option_was_supplied( "-sample-missing-rate" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *sample_filter, "missing", m_options.get_value< double >( "-sample-missing-rate" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-heterozygosity" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *sample_filter, "heterozygosity", m_options.get_values< double >( "-heterozygosity" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-incl-samples" ) ) {
			std::vector< std::string > filenames = m_options.get_values< std::string >( "-incl-samples" ) ;
			std::auto_ptr< OrRowCondition > inclusion_condition( new OrRowCondition() ) ;
			for( std::size_t i = 0; i < filenames.size(); ++i ) {
				std::auto_ptr< RowCondition > sample_incl_condition( new SampleInListCondition( filenames[i] )) ;
				inclusion_condition->add_subcondition( sample_incl_condition ) ;
			}
			sample_filter->add_subcondition( std::auto_ptr< RowCondition >( inclusion_condition.release() ) ) ;
		}

		if( m_options.check_if_option_was_supplied( "-excl-samples" ) ) {
			std::vector< std::string > filenames = m_options.get_values< std::string >( "-excl-samples" ) ;
			for( std::size_t i = 0; i < filenames.size(); ++i ) {
				std::auto_ptr< RowCondition > sample_incl_condition( new SampleInListCondition( filenames[i] )) ;
				std::auto_ptr< RowCondition > sample_excl_condition( new NotRowCondition( sample_incl_condition )) ;
				sample_filter->add_subcondition( sample_excl_condition ) ;
			}
		}
		
		m_sample_filter = sample_filter ;
		m_sample_filter_failure_counts.resize( m_sample_filter->number_of_subconditions(), 0 ) ;
	}

	template< typename ConditionType >
	void add_one_arg_condition_to_filter( AndRowCondition& filter, std::string const& statistic_name, double value ) {
		std::auto_ptr< RowCondition > condition( new ConditionType( statistic_name, value )) ;
		filter.add_subcondition( condition ) ;
	}

	template< typename ConditionType >
	void add_two_arg_condition_to_filter( AndRowCondition& filter, std::string const& statistic_name, std::vector< double > values ) {
		assert( values.size() == 2 ) ;
		std::auto_ptr< RowCondition > condition( new ConditionType( statistic_name, values[0], values[1] )) ;
		filter.add_subcondition( condition ) ;
	}

	void process_other_options() {
		m_ignore_warnings = m_options.check_if_option_was_supplied( "-force" ) ;
	}
	
	genfile::CohortIndividualSource::UniquePtr open_samples( std::size_t const expected_number_of_samples ) {
		try {
			return unsafe_open_samples( expected_number_of_samples ) ;
		}
		catch( ConditionValueNotFoundException const& ) {
			m_ui_context.logger() << "\n\n!! ERROR: The input sample file must contain entries for all values used to filter on.\n"
				<< "!! This includes \"missing\" and \"heterozygosity\".\n" ;
			throw ;
		}
		catch( genfile::MalformedInputError const& e ) {
			m_ui_context.logger() << "\n\n!! ERROR (" << e.what() << "): the sample file \"" << e.source() << "\" is malformed on line "
				<< e.line() + 1 ;
			if( e.has_column() ) {
				m_ui_context.logger() << ", column " << e.column() + 1 ;
			}
			m_ui_context.logger() << ".  Quitting.\n" ;
			throw ;
		}
		catch( genfile::MismatchError const& e ) {
			m_ui_context.logger() << "\n\n!! ERROR (" << e.what() << "): in source \""
				<< e.source() << ": incorrect number of samples in the sample source ( "
				<< e.key1()  << ", " << e.key2()
				<< ").\n" ;
			m_ui_context.logger() << ".  Quitting.\n" ;
			throw ;
		}
	}
	
	genfile::CohortIndividualSource::UniquePtr unsafe_open_samples( std::size_t const expected_number_of_samples ) {
		genfile::CohortIndividualSource::UniquePtr sample_source ;
		if( m_mangled_options.input_sample_filenames().size() == 0 ) {
			sample_source.reset( new genfile::CountingCohortIndividualSource( expected_number_of_samples, "sample_%d" ) ) ;
		}
		else {
			genfile::CohortIndividualSourceChain::UniquePtr source_chain( new genfile::CohortIndividualSourceChain() ) ;
			for( std::size_t i = 0; i < m_mangled_options.input_sample_filenames().size(); ++i ) {
				source_chain->add_source(
					genfile::CohortIndividualSource::UniquePtr(
						new genfile::CategoricalCohortIndividualSource(
							m_mangled_options.input_sample_filenames()[i],
							m_options.get_value< std::string >( "-missing-code" )
						)
					)
				) ;
			}
			sample_source.reset( source_chain.release() ) ;
			
			if( sample_source->get_number_of_individuals() != expected_number_of_samples ) {
				throw genfile::MismatchError(
					"QCToolCmdLineContext::unsafe_open_samples()",
					sample_source->get_source_spec(),
					"number of samples = " + genfile::string_utils::to_string( sample_source->get_number_of_individuals() ),
					"expected number of samples = " + genfile::string_utils::to_string( expected_number_of_samples )
				);
			}
			
			if( m_options.check_if_option_was_supplied( "-quantile-normalise" )) {
				sample_source = quantile_normalise_columns(
					sample_source,
					genfile::string_utils::split_and_strip(
						m_options.get_value< std::string >( "-quantile-normalise" ),
						","
					)
				) ;
			}
		}
		
		return sample_source ;
	}
			
	void load_sample_rows( genfile::CohortIndividualSource::UniquePtr const& sample_source ) {
		SampleRow sample_row ;
		assert( sample_source.get() ) ;
		for( std::size_t i = 0; i < sample_source->get_number_of_individuals(); ++i ) {
			sample_row.read_ith_sample_from_source( i, *sample_source ) ;
			m_sample_rows.push_back( sample_row ) ;
			if( !m_sample_filter->check_if_satisfied( sample_row )) {
				m_indices_of_filtered_out_samples.push_back( m_sample_rows.size() - 1 ) ;
			}
		}
	}
	
	genfile::CohortIndividualSource::UniquePtr condition_on(
		genfile::CohortIndividualSource::UniquePtr samples,
		genfile::SNPDataSource& snps,
		std::string const& conditioning_spec
	) {
		genfile::WithSNPDosagesCohortIndividualSource::SNPDosageSpec spec ;

		using genfile::string_utils::split_and_strip ;
		using genfile::string_utils::split ;
		std::vector< std::string > elts = split_and_strip( conditioning_spec, ",", " \t" ) ;
		for( std::size_t i = 0; i < elts.size(); ++i ) {
			std::vector< std::string > parts = split( elts[i], "(" ) ;
			if( parts.size() == 1 ) {
				parts.push_back( "add" ) ;
			}
			else if( parts.size() != 2 ) {
				throw genfile::BadArgumentError( "QCToolContext::condition_on()", "conditioning_spec=\"..." + elts[i] + "...\"" ) ;
			} else if( parts[1][ parts[1].size() - 1 ] != ')' ) {
				throw genfile::BadArgumentError( "QCToolContext::condition_on()", "conditioning_spec=\"..." + elts[i] + "...\"" ) ;
			} 
			
			if( parts[1][ parts[1].size() - 1 ] == ')' ) {
				parts[1].resize( parts[1].size() - 1 ) ;
			}

			genfile::SNPIdentifyingDataTest::SharedPtr snp_matcher(
				genfile::WithSNPDosagesCohortIndividualSource::create_snp_matcher( parts[0] ).release()
			) ;
			
			std::vector< std::string > types = split( parts[1], "|" ) ;
			for( std::size_t j = 0; j < types.size(); ++j ) {
				if( types[j] == "gen" ) {
					types[j] = "add" ;
					types.push_back( "het" ) ;
				}
			}

			spec[ snp_matcher ] = std::set< std::string >( types.begin(), types.end() ) ;
		}

		genfile::CohortIndividualSource::ConstUniquePtr const_samples( samples.release() ) ;
		return genfile::CohortIndividualSource::UniquePtr(
			genfile::WithSNPDosagesCohortIndividualSource::create( const_samples, snps, spec )
			.release()
		) ;
	}
	
	genfile::CohortIndividualSource::UniquePtr quantile_normalise_columns(
		genfile::CohortIndividualSource::UniquePtr source,
		std::vector< std::string > const& column_names
	) const {
		genfile::ValueMappingCohortIndividualSource::UniquePtr value_mapping_source(
			new genfile::ValueMappingCohortIndividualSource( source )
		) ;
		for( std::size_t i = 0; i < column_names.size(); ++i ) {
			add_normalisation( *value_mapping_source, column_names[i] ) ;
		}
		return genfile::CohortIndividualSource::UniquePtr( value_mapping_source.release() ) ;
	}

 	void add_normalisation(
		genfile::ValueMappingCohortIndividualSource& source,
		std::string const& column_name
	) const {
		genfile::CohortIndividualSource::ColumnSpec column_spec = source.get_column_spec() ;
		std::size_t column_i = column_spec.find_column( column_name ) ;
		if( !column_spec[ column_i ].is_continuous() ) {
			throw genfile::BadArgumentError( "qctool::quantile_normalise_columns()", "column_name = \"" + column_name + "\"" ) ;
		}
		genfile::CrossCohortCovariateValueMapping::UniquePtr mapping(
			new genfile::QuantileNormalisingCrossCohortCovariateValueMapping( column_name )
		) ;
		mapping->add_source( source ) ;
		source.add_mapping( column_name, column_name + ":quantile_normalised", mapping ) ;
	}

	void check_for_errors_and_warnings() {
		check_for_errors() ;
		check_for_warnings() ;
	}

	void check_for_errors() {
		if( m_mangled_options.gen_filename_mapper().input_files().size() == 0 ) {
			m_errors.push_back( "At least one GEN input file must be supplied." ) ;
		}

		for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().input_files().size(); ++i ) {
			for( std::size_t j = 0; j < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++j ) {
				if( strings_are_nonempty_and_equal( m_mangled_options.gen_filename_mapper().output_filenames()[j], m_mangled_options.gen_filename_mapper().input_file( i ).filename() )) {
					m_errors.push_back( "Output GEN file \"" + m_mangled_options.gen_filename_mapper().output_filenames()[j] +"\" also specified as input GEN file." ) ;
					break ;
				}
			}
			if( strings_are_nonempty_and_equal( m_mangled_options.output_sample_filename(), m_mangled_options.gen_filename_mapper().input_file( i ).filename() )) {
				m_errors.push_back( "Output SAMPLE file \"" + m_mangled_options.output_sample_filename() +"\" also specified as input GEN file." ) ;
				break ;
			}
		}
		for( std::size_t j = 0; j < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++j ) {
			if( strings_are_nonempty_and_equal( m_mangled_options.output_sample_filename(), m_mangled_options.gen_filename_mapper().output_filenames()[j] )) {
				m_errors.push_back( "The GEN and SAMPLE output filenames must differ." ) ;
			}
		}
		if( m_mangled_options.input_sample_filenames().size() == 0 && m_sample_filter->number_of_subconditions() != 0 ) {
			m_errors.push_back( "To filter on samples, please supply input sample files." ) ;
		}
		if( m_snp_filter->number_of_subconditions() > 0 && m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() == 0 && m_mangled_options.gen_filename_mapper().output_filenames().size() == 0 ) {
			m_errors.push_back( "You have specified SNP filters, but no output SNP exclusion list or output GEN files.\n" ) ;
		}
	}
	
	void check_for_warnings() {
		if( m_mangled_options.output_sample_stats_filename() != "" && m_mangled_options.input_sample_filenames().size() == 0 ) {
			m_warnings.push_back( "You are outputting a sample statistic file, but no input sample files have been supplied.\n"
			"   Statistics will be output but the ID fields will be templates.") ;
		}
		if( m_snp_data_source->total_number_of_snps() && *m_snp_data_source->total_number_of_snps() == 0 ) {
			m_warnings.push_back( "There are no SNPs in the source files (after exclusions, translation, aligning and matching between cohorts where relevant).\n" ) ;
		}
		if( m_sample_rows.size() == 0 ) {
			m_warnings.push_back( "There are no individuals in the source files (after exclusions, translation, aligning and matching between cohorts where relevant).\n" ) ;
		}
	}
	
	bool strings_are_nonempty_and_equal( std::string const& left, std::string const& right ) {
		return (!left.empty()) && (!right.empty()) && (left == right) ;
	}

} ;

struct QCToolApplication: public appcontext::ApplicationContext
{
public:
	QCToolApplication( int argc, char** argv ):
		appcontext::ApplicationContext( globals::program_name, globals::program_version, std::auto_ptr< appcontext::OptionProcessor >( new QCToolOptionProcessor ), argc, argv, "-log" )
	{
		process() ;
	}
	
private:
	
	void process() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			get_ui_context().logger() << "!! Error (" << e.what() << "): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileNotFoundError const& e ) {
			get_ui_context().logger() << "\nError: No file matching \"" << e.filespec() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	void unsafe_process() {
		std::size_t const number_of_threads = options().get_value< std::size_t >( "-threads" ) ;
		worker::Worker::UniquePtr worker ;
		if( number_of_threads > 0 ) {
			worker.reset( new worker::QueuedMultiThreadedWorker( number_of_threads )) ;
		} else {
			worker.reset( new worker::SynchronousWorker() ) ;
		}

		QCToolCmdLineContext context(
			options(),
			get_ui_context()
		) ;

		genfile::SimpleSNPDataSourceProcessor processor ;

		if( options().check( "-o" ) ) {
			SNPSummaryComponent component(
				context.get_cohort_individual_source(),
				options(),
				get_ui_context()
			) ;
			
			component.setup( processor ) ;
		}

		if( options().check( "-sample-stats" ) ) {
			SampleSummaryComponent::UniquePtr component = SampleSummaryComponent::create( options(), context.get_cohort_individual_source(), get_ui_context() ) ;
			component->setup( processor ) ;
		}
		
		std::auto_ptr< DataReadTest > data_read_test ;
		if( options().check_if_option_was_supplied( "-read-test" )) {
			data_read_test.reset( new DataReadTest() ) ;
			processor.add_callback( *data_read_test ) ;
		}
		
		std::auto_ptr< VCDBWriter > db_writer ;
		if( options().check_if_option_was_supplied( "-write-db" )) {
			db_writer = VCDBWriter::create( options() ) ;
			processor.add_callback( *db_writer ) ;
		}

		if( options().check_if_option_was_supplied_in_group( "Kinship options" )) {
			RelatednessComponent::UniquePtr relatedness_component = RelatednessComponent::create(
				options(),
				context.get_cohort_individual_source(),
				worker.get(),
				get_ui_context()
			) ;
			relatedness_component->setup( processor ) ;
		}

		ClusterFitter::UniquePtr cluster_fitter ;
		if( options().check_if_option_was_supplied( "-fit-clusters" ) ) {
			cluster_fitter = ClusterFitter::create( options() ) ;
			processor.add_callback( *cluster_fitter ) ;
		}

		if( options().check_if_option_was_supplied_in_group( "Call comparison options" )) {
			CallComparerComponent::UniquePtr component = CallComparerComponent::create(
				context.get_cohort_individual_source(),
				options(),
				get_ui_context()
			) ;

			component->setup( processor ) ;
		}
		
		ClusterPlotter::UniquePtr cluster_plotter ;
		if( options().check_if_option_was_supplied_in_group( "Cluster plot options" )) {
			cluster_plotter = ClusterPlotter::create( options(), worker.get() ) ;
			processor.add_callback( *cluster_plotter ) ;
		}
		
		HaplotypeFrequencyComponent::UniquePtr haplotype_frequency_component ;
		if( options().check_if_option_was_supplied_in_group( "LD computation options" )) {
			haplotype_frequency_component = HaplotypeFrequencyComponent::create(
				context.open_snp_data_sources(
					genfile::wildcard::find_files_by_chromosome(
						options().get< std::string >( "-compute-ld-with" ),
						genfile::wildcard::eALL_CHROMOSOMES
					)
				),
				options(),
				get_ui_context()
			) ;
			processor.add_callback( *haplotype_frequency_component ) ;
		}

		if( options().check( "-og" ) || options().check( "-op" ) ) {
			SNPOutputComponent::setup(
				context.get_cohort_individual_source(),
				context.fltrd_in_snp_data_sink(),
				processor
			) ;
		}
		// Process it (but only if there was something to do) !
		if( processor.get_callbacks().size() > 0 ) {
			UIContext::ProgressContext progress_context = get_ui_context().get_progress_context( "Processing SNPs" ) ;
			processor.process( context.snp_data_source(), progress_context ) ;
		} else {
			get_ui_context().logger() << "SNPs do not need to be visited -- skipping.\n" ;
		}
	}
} ;

int main( int argc, char** argv ) {
    try {
		QCToolApplication app( argc, argv ) ;
    }
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
